OP_ADDI REG0 REG1 0000000000010100  // mov r1, 20 (size of array) 	
OP_LSLI REG1 REG2 0000000000011101  // mov r2, int_min 				
OP_SUBI REG2 REG3 0000000000000001  // mov r3, int_max			
OP_R REG0 REG0 REG4 SH0 FUNC_ADD 	// mov r4, 0						 

OP_LW REG4 REG5 0000000000000000 	// lw r5, [r4]					@4 jump goes here
OP_R REG5 REG3 REG6 SH0 FUNC_SLT 	// r6 = (r5 < r3) ? 1 : 0
OP_R REG2 REG5 REG7 SH0 FUNC_SLT 	// r7 = (r2 < r5) ? 1 : 0

OP_R REG0 REG6 REG6 SH0 FUNC_SUB 	// r6 = (r5 < r3) ? ffffffff : 0
OP_R REG0 REG7 REG7 SH0 FUNC_SUB 	// r7 = (r2 < r5) ? ffffffff : 0

OP_R REG5 REG3 REG8 SH0 FUNC_SUB   	// r8 = r5 - r3
OP_R REG5 REG2 REG9 SH0 FUNC_SUB   	// r9 = r5 - r2

OP_R REG8 REG6 REG8 SH0 FUNC_AND	// r8 = (r5<r3)?r5-r3:0
OP_R REG9 REG7 REG9 SH0 FUNC_AND	// r8 = (r2<r5)?r5-r2:0

OP_R REG8 REG3 REG3 SH0 FUNC_ADD
OP_R REG9 REG2 REG2 SH0 FUNC_ADD

OP_ADDI REG4 REG4 0000000000000001	// r4+=1 (point to next)
OP_SUBI REG1 REG1 0000000000000001  // r1-=1 (dec size)
OP_J OP_REL OP_INV COND_Z 11111111111111111111110010

OP_R REG2 REG3 REG4 SH0 FUNC_MULL
OP_R REG2 REG3 REG5 SH0 FUNC_MULH



//check other instructions now

OP_SW REG0 REG4 0000000000010101
OP_SW REG0 REG5 0000000000010110 //store result

//rested lw, sw, addi, subi, lsli, slt, sub, and, add, bnz, mul, j
//remain -or nor -xor lsr -asr -ror -div -rem 

OP_R REG8 REG8 REG8 SH0 FUNC_XOR // reg8=0;
OP_ORI REG8 REG8 0000000000010101 // r8 = 21
OP_RORI REG8 REG8 0000000000000001 // ror r8, 27 | r8 = 100000000000000000000000000000001010
OP_ASRI REG8 REG8 0000000000011111 // r8 = ffffffff = -1
OP_LSRI REG8 REG8 0000000000000001 // R8 BE INT_MAX
OP_LSRI REG8 REG9 0000000000011101 // r9 = 1
OP_R REG8 REG9 REG10 SH0 FUNC_DIV //mb intmax
OP_R REG8 REG9 REG11 SH0 FUNC_REM //mb 1

OP_SW REG0 REG11 0000000010000000 //write remainder to output port

OP_J OP_ABS OP_INV COND_Z 00000000000000000000011111 // infinite loop (i hate absolute addressing)
